{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"What is FRAM?","text":"The version of FRAM that is currently published is a Minimum Viable Product, meaning that it has minimum functionality to run a simple power market model. We are working on adding more features.    <p>FRAM is an open-source modelling framework developed by the Norwegian Water Resources and Energy Directorate (NVE) that allows you to build and run different energy market models and compare them to each other. </p> <p>If you previously saw a FRAM presentation, you might want to go directly to FRAM demo on GitHub. </p> <p>Here is a video demonstration of the FRAM demo with the JulES model.</p>"},{"location":"#architecture-of-fram","title":"Architecture of FRAM","text":"<p>FRAM gets data from a common model-neutral database and efficiently performs all necessary data transformations and operations needed to build a model, solve it, and get the results.</p> <p></p> <p>FRAM simplifies working with models for analysts and reduces the time needed to build and run power market models and get results. It ensures consistency between models, as they are created from the same dataset. Each model is only integrated into the model framework once, and then the analysts can run models and scenarios, sequentially or in parallel, adjusting the workflow depending on the specific analysis.</p> <p>Contact: fram@nve.no</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Universal and model independent design - you can connect any power market model to FRAM. The current release includes an API and tutorials for running the open-source power market model JulES.</li> <li>Innovative data processing system - FRAM can efficiently perform complex operations like aggregation, disaggregation, and can handle different units and time dimensions.</li> <li>Fast and efficient - data processing in FRAM is designed to be fast and have efficient memory use.</li> <li>Modular and flexible - you can extend the core model or replace components with your own.</li> </ul>"},{"location":"#fram-packages","title":"FRAM Packages","text":"<p>FRAM consists of several Python packages:</p> <p></p> <p>We suggest installing or downloading FRAM demo on GitHub to explore FRAM. It will install all other packages automatically for you.</p> <p>You will find documentation for each package following these links:</p> <ul> <li>FRAM core</li> <li>FRAM data</li> <li>FRAM JulES</li> <li>FRAM demo</li> </ul>"},{"location":"how_fram_works/","title":"How FRAM works","text":"<p>The main component of FRAM is the core model in  the FRAM core package, which creates a Python object Model() that holds the data from the database. The data in the Model object is transformed depending on what is required by the given power market model. </p> <p>Data is imported from the database using a Populator class in the FRAM data package.  </p> <p>Data is sent to a power market model through the FRAM solver interface defined in FRAM core package. The current release has an implementation of a solver in FRAM JulES.</p>"},{"location":"how_fram_works/#architecture-of-fram","title":"Architecture of FRAM","text":"<p>The Model object contains high-level components (Python objects) that hold the data about specific elements in the power system, for example power plants, demand, transmission etc. High-level components can be represented as low-level components  - flows and nodes. For example, demand is a flow with an arrow towards a node, while production is a flow with an arrow away from a node.</p> <p>Different kinds of nodes can be defined - emission nodes, power nodes, fuel nodes etc. In this way, the system supports modelling not only the power market, but also other adjacent markets - the heating market, emission market, gas market, etc.</p> <p>Data in the core model can be easily manipulated - aggregated, disaggregated and converted, with respect to different units and time resolution, etc. This is how data can be staged for a given energy marked model run.</p> <p>Through the solver interface, data is sent to the power market model, and results are sent back from the solved model to core model. Core model has fields for 'feeding in' results from different models. For example, a Node() object has a field where you can set the price from a solved model. Model results can then also be manipulated, through aggregation and disaggregation, etc., which simplifies comparison between models.</p> <p>For more details about the core model, see FRAM core.</p> <p>For more details about the database and data package, see FRAM data.</p> <p>For more information about the JulES API, see FRAM JulES.</p>"},{"location":"how_to_add_model/","title":"How to connect a new energy market model?","text":""},{"location":"how_to_add_model/#what-is-required-to-add-a-new-energy-market-model-to-fram","title":"What is required to add a new energy market model to FRAM?","text":"<p>To connect a new energy market model to FRAM you need to create an API for the model - a Python package that will connect the core model to the optimisation algorithm in the energy market model.</p> <p></p> <p>Use JulES API package (fram-jules) from our simple demo as an example. </p> <p>An energy market model is normally a third-party software that contains an algorithm for solving a market optimisation problem, as well as the model input data and output data in some format. The algorithm for solving the optimisation problem may be implemented in different languages, e.g. GAMS, Julia, Matlab etc. Many models have their own interfaces for handling the input and the output data. </p> <p>To connect the model to FRAM you have to create an API package that understands the core model, is able to get data from it, send it to the third party software and start the optimisation. It will also have to read the results of the optimisation and send them back to the core model. The two most important methods you have to implement are get_config and solve methods. Interfaces for them can be found in FRAM core:</p> <ul> <li>framcore.solvers.Solver.py</li> <li>framcore.solvers.SolverConfig.py</li> </ul> <p>To be a Solver, the object must inherit from Solver() and have methods .get_config() and ._solve() (method .solve() must depend on method ._solve()).</p> <p>What is behind these methods may vary widely from model to model, depending on how the optimisation model was set up by its developers. For most optimisation models, the Solver-method will have to create all necessary input files in some format (e.g. csv, h5 or txt) and call upon the optimisation software (e.g. GAMS solve or juliacall). It will also have to read output files in some format (e.g. txt) and put data back into the Model() object.  </p> <p>Note that in many cases, it may be easier to pass-by the original user interface of the energy market model to avoid redundant steps. It may for example be easier and faster to create input files and call upon the optimisation software directly instead of calling upon some functions in the user interface that will afterwards perform the same operations. </p>"},{"location":"how_to_add_model/#do-i-need-to-add-something-to-the-core-model","title":"Do I need to add something to the core model?","text":"<p>If the energy market model you want to connect has data that is not yet supported in the core model, one of the alternatives is to create new components in the core model (or reuse the existing components if possible). If you create new components, you also have to send new data from the database to the core model, i.e. extend the Populator and add new data validation steps. The core model is constantly under development, and we are constantly adding support for new components. If you have added new components that may be useful for others, tell us about it so we can extend the core model with your components. </p> <p>Another alternative is to add model-specific input via SolverConfig. Than this input will only be relevant for this specific model and other energy market models will not be able to make use of it. An example can be model-specific calibration or model-specific factors that no other models use. </p>"},{"location":"how_to_add_model/#how-to-send-data-from-the-core-model-to-the-solver","title":"How to send data from the core model to the Solver?","text":"<p>Some models operate with \"concrete\" data models where input data is based on \"real-world\" definitions (thermal, demand, transmission, etc). These models can use existing high-level components in the core model directly. For example, if your model needs a smart house component, try to define it using existing components demand, battery and solar plant. </p> <p>You can also define your own components - in this case you have to update the Populator so that it knows about the new components. </p> <p>Other models have more \"abstract\" data models, like nodes and flows. FRAM core model supports these models as well because all high-level components can be decomponsed into low-level, more abstract components flow and node. These are the most basic components in the core model.</p> <p>Models with \"concrete\" data models can also use low-level components, though it may be not intuitive in the start. This approach can give some significant advantages where you will get much more \"clean code\" and avoid a lot of duplicate code. See our examples with JulES model to understand better how to flow and node components are used.</p>"},{"location":"how_to_contact/","title":"How to contact us?","text":"<p>Do you want to know more about FRAM or contribute into the development?</p> <p>Are you trying to run the demo or use FRAM and have problems?</p> <p>Do not hesitate to contact us at fram@nve.no!</p>"},{"location":"installation_and_demo/","title":"Installation and demo","text":""},{"location":"installation_and_demo/#get-started-with-the-fram-demo","title":"Get started with the FRAM demo","text":"<p>We recommend that you set up our simple demo to get started with FRAM. Go to the demo page on GitHub and follow the installation steps. </p> <p>The demo installation will install all the necessary dependenies for FRAM and all FRAM packages. It will also install the open-source power market model JulES and a demo dataset so that you can run a simple modelling case and see how FRAM works. </p>"},{"location":"installation_and_demo/#separate-installation-of-fram-packages","title":"Separate installation of FRAM packages","text":"<p>If you still want to install different packages separately, you can use:</p> <pre><code>  pip install fram-core\n</code></pre> <p></p> <pre><code>  pip install fram-data\n</code></pre> <p></p> <pre><code>  pip install fram-jules\n</code></pre> <p></p>"},{"location":"installation_and_demo/#separate-download-of-demo-dataset","title":"Separate download of demo dataset","text":"<p>To download the dataset separately, go to FRAM demo dataset and download the zip-file.</p>"},{"location":"what_special_jules/","title":"What is special about JulES?","text":"<p>JulES is a fundamental energy market simulation model for operational planning, developed by NVE and applied in the FRAM demo. It uses TuLiPa as building blocks.</p> <p>The model is specifically designed to handle an extremely large number of storage units, which is essential for hydropower modelling. This requires an algorithm that applies simplifications without compromising the quality of the results.  </p> <p>Unlike approaches such as SDDP or SDP, JulES does not attempt to compute an optional strategy for the entire planning horizon in advance. Instead, it computes strategies dynamically as the simulation progresses, dividing the problem into smaller subproblems and using parallelization. We believe this offers better scalability.   </p> <p>The flow in the algorithm is illustrated in the figure below. From each starting point, the simulation proceeds in three main steps:  </p> <ol> <li> <p>Price prognosis: JulES generates price forecasts for each weather scenario (often 30 years) at multiple time scales. The price projections have varying lengths and granularities. They use the same time horizon, but the time resolution is most detailed in the short-term and becomes coarser the further ahead we look on the horizon (less detail for long-term). It is solved efficiently by aggregating over time and space, and solving the weather scenarios in parallel. Along with coarser time resolution long-term, an important aggregation is that the price forecasts use aggregated hydropower, while the next step uses more detail. The time scales are:  </p> <ul> <li>Long-term: up to five years ahead  </li> <li>Medium-term: one year ahead  </li> <li>Short-term: one week </li> </ul> </li> <li> <p>Storage values: For all storage systems that must anticipate future conditions to make bids \u2013 such as reservoirs and other hydro assets, JulES solves stochastic programming problems using Bender\u2019s decomposition. The resulting storage values for all storages/reservoirs, are then used as inputs to the market clearing step.</p> </li> <li> <p>Market clearing: Finally, the market is cleared based on the updated state. At this point, all relevant information is available: short-term conditions and updated storage values. The full market is cleared in a single joint step, with all units and constraints included.  </p> </li> </ol> <p>When the three steps have been performed, the market clearing feeds into a new starting state, for which the process is continuously repeated. By dividing the problem into separate steps and applying parallelization, JulES achieves good scalability.  </p> <p>In addition, JulES computes inflow models based on the current starting state. As the figure shows, these inflow estimates feed into the price prognosis and storage\u2011value calculations in steps 1\u20132.  This forms part of JulES\u2019 data\u2011driven forecasting framework, which continuously updates continuously updates future scenarios based on the initial state. </p> <p></p> <p>Currently, the model includes simple demand with reservation prices, and batteries to represent short-term storage and demand shifting. In addition, JulES can handle sector couplings (fire wood, substitution effects).</p> <p>For documentation and code for the JulES model, see JulES on Github.</p> <p>For more information about the JulES API connecting FRAM to JulES, see FRAM JulES.</p>"},{"location":"why_components/","title":"Why do we have high-level and low-level components in the core model?","text":"<p>The components describe the main elements of the modelled energy systems in FRAM. We have high-level and low-level components in the core model, which are all Python objects. </p>"},{"location":"why_components/#high-and-low-level-representations-of-energy-systems","title":"High- and low-level representations of energy systems","text":"<p>The high-level components are for instance demand, transmission and hydropower components that are described in input data to FRAM. The high-level descriptions let analysts work with recognizable domain objects. All high-level components in FRAM, e.g. Demand, have the method self.get_simpler_components(), and most also have self.create_flow(). These translate the high-level component to low-level components (flow and node), to be used in modelling. </p> <p>The low-level descriptions express the same energy system components in a highly abstract and generic form. This enables generic algorithms that minimize code duplication and simplify data manipulation, especially convenient for developers. Read below to understand why this decomposition is so useful.</p>"},{"location":"why_components/#why-convert-between-high-level-and-low-level","title":"Why convert between high-level and low-level?","text":"<p>The main advantages of converting between high-level and low-level components are possibility to write more generic code for data calculations and compatibility with energy system models that already operate with low-level components:</p> <ol> <li> <p>More generic code: possibility to decompose high-level components into more generic flows and nodes allows writing much more generic algorithms for data calculations and avoiding duplicating code. For example, instead of writing the same data processing functions for PowerPlant and Demand components (because they have many similar features), you can write a generic function for flow and node that will apply for all components of the same type. This is especially useful for developers who want to work with FRAM and build tools for analysts.</p> </li> <li> <p>Compatibilty with abstract energy market models: several models, like JulES, SpineOpt and PyPSA, already use a low-level generic description of the system. FRAM supports such types of models better because the data can be easily \u201ctranslated\u201d into the low-level representation. </p> </li> </ol>"},{"location":"why_components/#low-level-components-flow-and-node","title":"Low-level components: flow and node","text":"<p>Nodes and flows are the main building blocks in FRAM's low-level representation of energy systems. </p> <p>A node represents a point where a commodity can possibly be traded, stored or just pass through. Examples of commodities in FRAM are power and hydro. Nodes can represent a physical point, but also an abstract energy system component, for instance a bidding zone. </p> <p>The transport or flow of a commodity between nodes is represented by flows. Flows represent movement through the energy system, for instance power being produced in a power node (see the first example below), or conversion between hydro and power commodities (see the second example below). A flow can be connected to one or more nodes.</p> <p>In FRAM, flows have attributes called arrows that determine direction of the movement. Several arrows can be connected to a single flow, where each describe the contribution from the flow into a node. The arrows have a direction to determine whether it is input or output to the node, and parameters for the contribution of the flow to the node (conversion, efficiency and loss) (see the second example below). In FRAM, arrows are also Python-objects with their own attributes.</p>"},{"location":"why_components/#how-are-high-level-components-represented-as-low-level-components-in-fram","title":"How are high-level components represented as low-level components in FRAM?","text":""},{"location":"why_components/#example-node-and-two-flows","title":"Example node and two flows","text":"<p>Let\u2019s take an example of solar production in bidding zone Germany. A high-level component for the total solar production in the zone can have the below attributes. To relate the solar to its location in the power system, one of the attributes is which (power) node it connects to:  </p> <pre><code>{Solar:  \n    power_node: DEU,  \n    max_capacity: 70 GW,  \n    min_capacity: None,  \n    variable_operation_cost: None,  \n    production: [0.8 GWh/h, 0.9 GWh/h, 0.9 GWh/h, ... ],  \n    \u2026  \n    }  \n</code></pre> <p>FRAM can decompose the same solar production of the power commodity feeding into the DEU bidding zone into the low-level components flow and node. </p> <p>The below figure illustrates this \u2013 the bidding zone DEU is represented as a power node for Germany, solar power production is as a flow into the node and demand is a flow out of the node. Below, low-level components of the F<sup>SolarDEU</sup> flow and the DEU node are shown.</p> <p></p> <p>In this example case, the low-level representation of the DEU solar production as a flow would be as follows: </p> <pre><code>{Flow:  \n    main_node: DEU,  \n    max_capacity: 70 GW,  \n    min_capacity: None,  \n    startupcost: None,  \n    volume: [0.8 GWh/h, 0.9 GWh/h, 0.9 GWh/h, ... ],  \n    arrow_volumes*: {\n        power_arrow: [0.8 GWh/h, 0.9 GWh/h, 0.9 GWh/h, ... ]\n        },\n} \n</code></pre> <p>* arrow_volumes are the same as volume in this example because the flow has just one arrow</p> <pre><code>{Node:  \n    commodity: Power,  \n    is_exogenous (to simulate the node endogenously or use a pre-set price): False, \n    price**: [3 EUR/MWh, 2.4 EUR/MWh, 1 EUR/MWh, \u2026],   \n    storage: None,   \n}  \n</code></pre> <p>* Price is the result of the optimisation sent back to the core model</p> <p>Changes made inside the attributes in low-level components will also appear in high-level components. </p>"},{"location":"why_components/#example-flow-and-node-with-storage","title":"Example flow and node with storage","text":"<p>Here is another example of decomposition of high-level components with storage - a hydropower plant with a reservoir. In FRAM, there are Python-objects called Storage() that have their own attributes and are connected to a node of the commodity. </p> <p>The figure below illustrates a low-level representation of a simple power system in NO2 with both power and hydro commodities. A hydropower plant (HPP) with a reservoir is connected to the bidding zone NO2. Because the hydropower reservoir has storage of the hydro commodity, the plant is represented as a node with storage and a flow towards the power node. In this case, the flow F<sup>Release</sup> from HPP to NO2 is a conversion between hydro and power. </p> <p></p> <p>The HPP node with storage above could have a low-level representation like:  </p> <pre><code>{Node:  \n    commodity: Hydropower,  \n    is_exogenous: False,  \n    price: [0.5, 1, 2, ...],  \n    storage: Storage(),  \n    },  \n</code></pre> <p>where the storage component would have attributes like:  </p> <pre><code>{Storage:  \n    capacity: 1,000 MW,  \n    volume (storage filling)*: [10, 25, 2, ...],  \n    loss: 0.01,   \n    reservoir_curve (water level elevation to water volume): [0.10, 0.15, 0.14, ...],   \n    initial_storage_percentage: 0.72,  \n    ...  \n    } \n</code></pre> <p>* Storage filling can be predefined or the result of the optimisation sent back to the core model</p>"},{"location":"why_core_model/","title":"Why do we need a core model?","text":"<p>The most important part of FRAM is the core model. This is a Python object that holds the information about all components in the modelled energy system. The energy market models access input data through the core model. Different energy models have different internal data models with their own level of detail, which support different modelling features and require different levels of input data detail and data formats. The core model is therefore an extra layer of data processing between the database and the model input / output in FRAM. A more detailed technical description of the core model can be found here. </p> <p>You might wonder, why do we need a core model at all? Why won't we just send the data directly from the database to the energy market model? If you are a user of the model framework and only work in a user interface, you might not care because you do not interact with the core model directly. But for developers and users who want to understand the technical side of the system this question is very important. </p> <p>The main reasons for having a core model is scalability of the solution and smart data manipulation. </p>"},{"location":"why_core_model/#scalability-of-the-solution","title":"Scalability of the solution","text":"<p>From a development perspective, the scalability and possibility to add more energy market models using the same data is an important advantage of the core model. </p> <p>Different energy market models have different internal data models with their own level of detail, which may support or not support some modelling features. It would be very difficult to build generic applications (for example, workflow running the analysis and dashboard showing the results) on top of these different data models without this extra data abstraction layer that the core model represents. </p> <p>Without the core model we would have to build an application that understands all possible data models and in addition all possible \"hacks\" that the analysts sometimes use when the model is missing support for some feature. This would not be scalable or reasonable or cost-efficient. Instead, the core model creates a stable and consistent API that different applications can use without being dependent on the various internal data models. </p>"},{"location":"why_core_model/#smart-data-manipulation","title":"Smart data manipulation","text":"<p>Core model is a descriptive model that uses Python objects to manipulate data. Therefore it takes advantage of all the strenghts of the object-oriented programming. And if you wonder why not just use Python dataframes to perform all data operations, here comes an explanation. </p> <p>Python dataframe is a table where data is stored in columns and rows - a way of representing the data that most of us are familiar with. For example, here is the data for a thermal power plant as a Python dataframe:</p> <p>Dataframe with attributes as columns</p> component efficiency startup_cost min_capacity \u2026 plant 1 0.5 100 40 \u2026 plant 2 0.4 150 50 \u2026 <p>And here is the same data represented as attributes in Python objects:  </p> <p>Attributes as \u201cfields\u201d in a core model component Thermal plant</p> <pre><code>{plant 1:  \n    efficiency: 0.5,  \n    startup_cost: 100,  \n    min_capacity: 40,  \n    \u2026  \n    },  \n{plant 2:  \n    efficiency: 0.4,  \n    startup_cost: 150,  \n    min_capacity: 50,\n    \u2026  \n    }  \n</code></pre> <p>Unlike dataframes, Python objects store both values and the logic for how those values should be interpreted and used, i.e. how each component should behave. Each object knows how to interpret its attributes because each attribute is described as a Python class. For example both Efficiency() and StartUpCost() in FRAM are Python classes with their own properites. Thermal plant component will therefore know exactly how to calculate efficiency, start-up cost and other attributes correctly when we for example want to aggregate thermal plants. </p> <p>We can also easily create different scenarios by creating different instances of an object, for example modifying data about minimum capacity of a Thermal plant. Or we can add new \"fields\" to support new functionality of a new energy market model that we want to connect to FRAM. </p> <p>Results from a model run can also be sent back to the Python object. For example we can store results about the production of the thermal plant in its own \"field\" in the Thermal plant component, so that it holds data on both input and output at the same time. This is very beneficial when we want to visualise data or compare results from different energy market models with each other.</p> <p>All the above functionality would be very difficult to achieve with python dataframes. We would have to add new columns and write extensive code that interprets the columns correctly and performs operations on the table in the way you want. For creating scenarios, we would need to handle different versions of the table with different rows or columns. We might also need to add model-specific columns to specify that attributes must be interpreted differently for different models. Handling tables, columns and rows would become complex and not scalable, and it would be harder to keep the data model independent. </p> <p>Another important advantage of using Python objects is the possibility to transform high-level components into low-level components. This is a simple operation with Python objects and almost impossible to achieve with dataframes. Read here why high- and low-level components are so important.</p>"},{"location":"why_is_it_called/","title":"Why it is called FRAM","text":"<p>FRAM is derived from the English word \"framework\". It is also the name of the Norwegian ship that due to its innovative design managed to sail farther towards the North Pole and the South Pole than any other ship did before.</p>      \"What, however, may be said to be new is the fact that we not only realized that the ship ought to have such a form, but that we gave it that form, as well as the necessary strength for resisting great ice-pressure, and that this was the guiding idea in the whole work of construction.\u201d          \u2014 Fridtjof Nansen, \u201cFarthest North\u201d, 1897 <p></p>"},{"location":"why_we_developed/","title":"Why we developed FRAM","text":"<p>At the Norwegian Water Resources and Energy Directorate (NVE), modelling is widely used to understand short-term and long-term developments in the power market. The possibility to run many models, many scenarios and compare them with each other is crucial for understanding the increasing complexity of the changing energy system. We saw a clear need to create a system that enables flexible and efficient use of different energy and power market models as different models are good at solving different problems. Therefore, we developed this modelling framework FRAM to support our analysts so that we could continue delivering quick and high-quality analyses in the future.\u202f </p> <p>Over time, we have transitioned from a fragmented landscape of Python scripts developed by different individuals, along with manual data handling and orchestration between models, to a unified system that meets our needs and ambitions. FRAM users can easily run the models they need, switch between models, and compare results \u2014 all within a unified and user-friendly environment. FRAM simplifies onboarding and training of new employees, reduces the risk of errors, and promotes consistency in analysis as all energy market models are built from the same database. We also wanted a modular system built on fast, efficient code and smart solutions \u2014 a tool that empowers both analysts and developers to work more effectively and collaboratively. </p> <p>Transparency has been a key priority. FRAM is completely open-source, and we at NVE hope that this system will be adopted by the industry and academia and will benefit the whole society. We encourage external stakeholders to contribute to FRAM development and create APIs for different power- and energy market models.   </p> <p>FRAM has been developed by a team of professional Python developers in collaboration with NVE\u2019s analysts, combining domain expertise in energy system analysis and modelling with professional software development skills. This collaboration between analysts and developers has ensured a robust framework that balances technical performance with practical usability \u2014 tailored to the needs of both users and contributors. </p> <p> One of NVE's key areas of responsibility is understanding the power market. Here showing S\u00e5heim hydropower plant in Telemark, Norway.</p>"}]}